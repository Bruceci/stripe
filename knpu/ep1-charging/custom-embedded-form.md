# Custom Embedded form

All right, really nice system going on now. Our code is organized, but we're still using Stripes custom form. Which is fine if you like it, but I want something that's a little more embedded into my site so it feels a little bit more like a native form.

Do that, go back to the strip docs. Instead of embedded for, which is what we have been using, go down to custom form. The way this is going to work is really similar. The biggest difference is we are responsible for actually creating the form with all the normal inputs and all that kind of stuff. Then we'll use a little bit of Stripe JavaScript to actually collect this data, send that to Stripe, and it will give us back the token the exact same way it's been doing before.

The first thing we need to do is actually start with the JavaScript. I'm going to copy this JavaScript file here, and then we're going go into our checkout template, and at the top I'm going to override the block JavaScripts and twig, call the parent function, and paste that there. All that did was make sure that this new JavaScript is included with the other JavaScripts on my page, because [base.html.twig 00:01:21] has a block JavaScripts down on the bottom. Notice we already have jQuery included, so we have access to using jQuery.

Perfect. Step two. We need to tell the JavaScript about our publishable key. Copy that code, put that down here, and the we already know from our original code that we can print a variable called stripe_public_key, and that's going to print that out. Inside of the actual quotes for the JavaScript we'll do {{stripe_public_key}}. Awesome.

Then the third step is actually to create the form itself. Fortunately, I've already done that work for us. Deleted the old, embedded form. Instead of us writing the form by hand, why don't you do {{include, and then say order/_cardform.html.twig. What that's doing is that's actually just reading this file right next to this template called _cardform.html.twig. Which I wrote simply to save us a little bit of time. As you can see, it is a normal html form, and as method post, the action is still empty so that it will submit right back to the same control, and then there's just a bunch of fields here that are rendered to look good with Twitter Bootstrap.

If you go back and refresh the page, now we have our own custom built-in form. There are a few really important things about this form. First of all, notice from input fields there is no name attribute. This is really, really important, because eventually we're going to submit this form, but we do not want to submit the actual fields. This data must not be submitted to our server because then we would be responsible for needing to be secure enough to handle credit card numbers and CVCs and those things. We do not want that.

The only thing we are going to submit is the same thing we've been submitting, which is the token that we get back from Stripe. Instead of having a name attribute, you're going to have a data-Stripe attribute, which tells Stripe what field this holds. Since this is the cardholder name, we have the data-Stripe = name, down here data-strip = number, data-Stripe = exp for the expiration field, and the CVC, and also the zip code.

I'm not making up these strings like cvcxb. If you look at Stripes documentation, that's what they want you call these. If you call them in just the right way then the Stripe JavaScript is going to automatically be able to look at your form and grab the fields off of it. It just saves you a little bit of time.

Now that we've got the form in place, the second thing we're going to do is actually copy some code here which is going to handle the form submit. Let's copy this in first and then we'll talk about it. This will go up here with the rest of our JavaScript. You paste that first chunk there, then if you scroll down a little bit more there is another function here called stripe_response_handler. We'll go in and paste that below that.

Perfect. If you look at this code, what it does is uses a jQuery [inaudible 00:05:24] block to find the form and then attach a submit handler. Because basically when the user hits submit on our form, we don't actually want to submit the form, we want to stop and send all the information to Stripe, and get the token back from Stripe. In our particular case I've given the form a class called js-checkout-form. I'm going to copy that class, and then change the JavaScript to look for .js-checkout.form. Then there's one [that I 00:05:50] spot further below, and we'll do that same thing there.

You'll notice that you use these js- classes a lot inside of my html. That's just a standard that I like to use whenever I attack a class to something. The purpose of that class is not for styling but for me to do something with it in JavaScript. I usually prefix them with js-.

When this form is submitted, we want to say event.preventDefault, and that will prevent the server from actually submitting. It's more or less the same thing as returning false down here, but client-preventDefault has some subtle advantages.

Next thing this does ... I'll indent this a little nicer ... is it finds the submit button so it can disable it because of course you don't want your users clicking the submit button multiple times. In our form I did the same thing. I gave us a class of js-submit-button. Let's copy that and make sure that works. There's one other spot down in the other function that references the button as well.

Then here is the actual important thing. This Stripe object here is the JavaScript object that we get from the Stripe library. We call createToken on it, we pass it the form. Now because we've put all these nice data-Stripe attributes onto our form, it's going automatically find those fields, send them to the Stripe server via an ajax call. Then once that ajax call finishes, it's going to call our Stripe response handler, and hopefully that will contain the token.

Now if there was a problem with that card, like it was an invalid credit card number or something like that, we need to show that error to the user. Down here inside of response.error, it finds some [div 00:07:52] called payment-errors and puts the message inside of that to the user. In our case I do have a div for this, and I call that js-checkout-error. What I did here is I have an alert, and alert danger, and then I add the bootstrap hidden field. This is hidden by default, but if we put a message into we're going to unhide it, and it will have really nice styling around it.

I'll change payment-errors to .js-checkout-error, and then we'll send the text, but we also need to remove the class hidden so that that message actually shows up. Of course this next line here removes the disabled prop so that the user can fix whatever information they need to and resubmit. Down below in the else, I'm actually going to paste some of this js-checkout-error stuff and we're going to add the class hidden. If the form is actually successful and that error is still showing there, we're going to hide the error real quick so the user doesn't think that they still have an error. That's it.

If we were successful, the adjacent responses are going to come back with a token, which we get via response.id, and then what we do is we manually put in a new input type equals hidden field called stripeToken, pass that value, and submit the form. Which is exactly what the old embedded form did. Eventually in our controller, we ended up with a Stripe token field that we can get off of request. In other words, this should all just work.

Let's go back, refresh the page. The first thing I want to do is actually try something that will have an error, which we haven't actually seen yet. I'll put a valid credit card number in ... notice he formatting is ugly ... but I'm not going to put in a valid expiration. That would be a expired expiration. Hit checkout, boom. In that case it tried to get ... it sent the ajax call to Stripe, Stripe came back with an error, we put the error in the box, and showed it to our user. That's awesome. If we fix this to a future date at checkout, everything should work perfectly. Awesome.

The only problem with this new form is that it's a lot uglier than the form that we used before, particularly all the number kind of run together when you put in the credit card information. I want to make this a little bit more user friendly. Fortunately Stripe gives us a really nice way to do that. If you look at [inaudible 00:10:57] and scroll down, eventually you're going to hear them reference a library called jQuery.payment, which is a little Java Script library for formatting those fields which they created.

If you want, you can look at this documentation. It even provides validation so you can do client-side validation, double check that the credit car is a valid credit card, or whatever you want. For us, I'm going to use it to actually format these fields so they don't look so ugly. I've already downloaded this JavaScript library into the webjs directory, so all we need to do is actually just include it on our page and point it at our form, and everything's going to work.

Up top I'll have a script tag, I'll have SRC equals, and then I'll include the js/jQueery.payment.min.js on the page. Then down here ... indent that ... yes, my indentation is messed up ... I'm going to say form.find, and I'm going to find the credit card number and pull it. I actually planned ahead and gave the credit card number input a special class of js-cc-number, and actually gave the expiration field js-cc-exp, and I gave the CVC field a class of js-cc-cvc.

I'm going to use those three classes to do a little JavaScript here. Look for a .js-cc-number, then we'd call .payment, then we'd say formatCardNumber. Then let's repeat that two more times for js-cc-exp, and then you call formatCardExpiry. Then we call formatCardCVC. This is purely just so things look a little bit better.

Now the card field, you can see we have ... Going to make sure you change that to CVC. It's purely so things look nicer. To go back and refresh. In the card number field it automatically puts nice spaces in there, and this is the most important one. Since we have the expiration in one field it automatically puts that slash there. I'm not adding that slash, it takes care of that slash for me, then it limits this CVC field to four numbers, because it's usually three or four numbers.

Custom forms are a little bit more work, but fundamentally they're the same thing. It's just up to you if you want to have control over how that form looks.

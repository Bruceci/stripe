# Centralize Stripe Code

In Stripe we're working with these nice invoice customer charge objects, but our code's getting a little crazy right now. We just have this big long line of code that's procedurally doing things. We need to organize this because eventually our logic with Stripe is going to be so complex that we need to start reusing some of this logic. This is going to become particularly important when we have subscription and we're handling things like what happens when we failed to charge a credit card or a user updates their credit card information. Here's the goal of the next few minutes. Get all of this organized into a really, really nice set of reusable functions so that we're flexible going into the future. To do that, inside the SRC app bundle directory, I'm going to create a new [inaudible 00:00:50] class called "Stripe Client". Make sure you give this the name space app bundle. We're going to fill this with functions that help us do our work with Stripe, functions like "Create Customer" or "Update Customer Card" or "Create Invoice".

Inside of our control actually the first thing we do is create a customer, so let's move this logic into this file by creating a public function "Create Customer". What we'll do is this will accept a user object, so the currently logged in user and then we'll also accept the payment token, the Stripe token that was just submitted. We'll copy all of this code here, put that into our Stripe Client object variable payment token. Then at the bottom we'll return that customer object just in case we actually need it from the other screen, so cool.

Now the only other problem with this function is down here with the entity manager, which we used actually update the user table with the new Stripe customer ID. This is very specific to Symphony, but in order for that to work, we need to create a new construct function, called a "Function Construct". We need to use dependency injection to inject the [inaudible 00:02:23] manager and then set that on a new EM property for Symphony people who are about to register this as a service. Then down below, we'd say EM equals this arrow EM and everything will work just fine. You're just transferring the exact same logic into this class.

In order to use this inside of our controller, in Symphony, we're going to go into app config services.lymel and we're going to register this nice service. It's [inaudible 00:02:57]Stripe into our clients. It needs a class key set to Stripe Clients. Then I'm going to use auto-wiring so that it will guess the arguments by controller and it does that by looking at the [inaudible 00:03:11]. If you're new to Symphony or you're not using this inside of Symphony, this is okay. The way you're going to organize your code is going to be a little bit different in your application, but ultimately I want you to build a reusable set of functions like this so you can interact with Stripe really easily.

Now in our controller, we can glean all this stuff. Before the if statement, I'm going to create a new variable called Stripe Client, inside this arrow, "Get stripe [inaudible 00:03:42] to our client," which is now going to be a new stripe client object s we can very easily say stripe client arrow create customer, passive user object, and then we will pass it the token. That's it. Good to go. Let's keep going with this.

The second bit of logic here, it's job is to update the credit card on an existing user. In Stripe Client, let's go back and create a second public function called "Update Customer Card". You'll accept the user object who's customer needs to be updated. Then once again we;'ll put a payment token and that's the token that represents the card. Just like before, I'm going to take these three lines, remove them from order controller, put them inside of here, update that token to payment token, and then we'll call it "Customer Arrow Save". In order controller, we'll just say Stripe Client, arrow, update customer card, pass [inaudible 00:04:56] user, and the token. You can see how we're being dangerous with this Stripe Client with all these really nice reusable functions.

Now there is one problem. This would work right now, but checkout this Stripe set API key thing up here. We have to call this before we make any API calls out to Stripe. If we started using this Stripe Client somewhere else in our code and we forgot to call this line, it's not going to work. I'm going to guarantee that if somebody works with our Stripe Client and calls methods like Create Customer, Update Customer, I'm going to guarantee that this line has already been called. The way we're going to do that is we're going to call this line from inside of the Stripe Client's constructor. Let's copy and remove that line, go to Stripe Client, and past this inside of construct.

The only other thing that needs changed is in Symphony we don't have [escape 00:06:02] parameter function from inside this class anymore. Instead of having this, I'm actually going to add a new first constructor argument called "Secret Key". Then on here, we're going to pass it secret key. Then in order for Symphony to pass us the secret key right there, in services.lymel, I'll add an arguments key and we'll set the first argument to percent stripe secret key percent. Because of auto-wiring it will pass that as the first value and then it will auto-wire the remaining arguments. This is very Symphony-specific, but one way or another we just need to make sure in  the construct function here, we're somehow getting our secret key from our configuration. Remember this is ultimately reading from parameters [inaudible 00:06:55] and [inaudible 00:06:55] so we can make sure that set API key is called. That's really the hardest stuff.

The last two things we can remove are a method to create an invoice item and a method to create an invoice. In Stripe Client, let's create those, public function, create invoice item. To do that we're going to need to know the amount of the invoice, we're going to need to know what use to attach that to and we'll also allow there to be an invoice item description. We'll copy the code from our controller, remove it, paste it here, and we'll just use amount and then place the description with description. Just in case, I'll add a return statement, in case we need that invoice item for some reason. In order controller, we'll just say, Stripe Client, arrow, create invoice item. We know that the amount is product error, get price, times 100. The user is our current user and I'm using product error, get name as the description. Awesome.

Then finally let's move this invoice create into our Stripe Client. You guys know it. Public function, create invoice. Remember we're always invoicing a specific user so we'll invoice that user. Then we'll add a little pay immediately argument and default it to true. There may be some times in the future when you want to create an invoice with subscriptions, but not actually have it invoice them immediately. That may never happen. That's why I defaulted it to true, but we have it there anyways. Here we'll grab the invoice code, remove that from our controller, put that into Stripe Client. Then we're at this invoice pay with, if pay immediately, then we will pay immediately and we'll return the invoice in case somebody needs it. This was a giant step sideways. I know it didn't add anything to our code but all the sudden we have a Stripe Client which is full of dangerous methods and inside of our controller we can just finish this with Stripe Client, arrow, create invoice, pass the user, and then pass it true, even though I don't have to to invoice immediately. That's it. This is going to pay off down the road. Double-check to make sure it works. Add something to your cart. Check-out. Unless we get an error, we're good. System still works and this Stripe Client is really, really dangerous
